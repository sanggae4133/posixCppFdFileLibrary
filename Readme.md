# PosixCppFdFileLibrary (FdFileLib)

A high-performance C++ file repository library using POSIX APIs (`open`, `read`, `write`, `fsync`) and `mmap` for efficient I/O. Supports both **Variable-Length (JSON-like)** and **Strict Fixed-Length (Binary)** record formats.

## Features

- **Performance**: Direct file I/O with minimal buffering. `mmap` used for fixed-length records (O(1) access).
- **Zero Overhead**: Fixed-length records use **CRTP (Curiously Recurring Template Pattern)** to eliminate virtual function overhead (no vtable).
- **Formats**:
  - **Variable**: Flexible JSON-style Key-Value storage.
  - **Fixed**: Strict binary layout with pre-calculated offsets for maximum speed.
- **Safety**: RAII wrappers for File Descriptors and Mmap. File locking support.
- **Usability**: Macro-based record definition for easy implementation.

## Project Structure

```
fdFileLib/
├── record/
│   ├── RecordBase.hpp           # Base Interface (for Variable Records)
│   ├── VariableRecordBase.hpp   # For variable-length records (Virtual)
│   ├── FixedRecordBase.hpp      # For fixed-length records (CRTP Template)
│   └── Macros.hpp               # Helper macros for Fixed Records
├── repository/
│   ├── RecordRepository.hpp     # Template Repository Interface
│   ├── VariableFileRepositoryImpl.hpp # Variable-length Repo
│   └── UniformFixedRepositoryImpl.hpp # Fixed-length Repo (Template)
├── util/                        # Utilities (Mmap, Lock, etc.)
└── CMakeLists.txt
```

## Getting Started

### Prerequisites
- C++17 compliant compiler
- CMake 3.16+
- POSIX environment (Linux/macOS)

### Build
```bash
mkdir build && cd build
# Generates compile_commands.json automatically
cmake ..
make

# or
cmake -S . -B build -DCMAKE_EXPORT_COMPILE_COMMANDS=ON
cmake --build build -j
```

---

## [English] Usage Guide

### 1. Using Fixed-Length Records (Recommended)

Strict Fixed-Length records offer **O(1) read/write performance**, **guaranteed data integrity**, and **zero virtual function overhead**.

#### Step 1: Define Record Class
Inherit from `FdFile::FixedRecordBase<T>` (CRTP) and use `FD_FIXED_DEFS` macro.

```cpp
#include "fdFileLib/record/FixedRecordBase.hpp"
#include "fdFileLib/record/Macros.hpp"

// CRTP Inheritance: Pass 'User' as template argument
class User : public FdFile::FixedRecordBase<User> {
public:
    char name[20];
    long age;

    // Define Layout & Auto-generate Methods
    // FD_FIXED_DEFS(Class, TypeName, TypeLen, IdLen, Fields...)
    FD_FIXED_DEFS(User, "User", 10, 10,
        FD_FIELD(name, name, 20, true), // true = string
        FD_FIELD(age, age, 5, false)    // false = number
    )

    // Default Constructor is auto-generated by macro!
    // User() { defineLayout(); }

    // Custom Constructor (Optional)
    User(const char* n, long a, long idVal) {
        std::memset(name, 0, sizeof(name));
        if (n) std::strncpy(name, n, sizeof(name));
        age = a;
        setRecordId(std::to_string(idVal));
        defineLayout(); // Must call defineLayout() in custom constructor
    }
};
```

#### Step 2: Use Repository
Use `UniformFixedRepositoryImpl<T>` (Template). No `dynamic_cast` required.

```cpp
#include "fdFileLib/repository/UniformFixedRepositoryImpl.hpp"

// Create Repository for 'User' type
std::error_code ec;
// Use User type as template argument. No prototype needed.
FdFile::UniformFixedRepositoryImpl<User> repo("data.db", ec);

// Save
User user("Alice", 30, 1001);
repo.save(user, ec);

// Find (O(N) sequential search for now, O(1) by index coming soon)
auto found = repo.findById("1001", ec);
if (found) {
    // 'found' is std::unique_ptr<User>
    std::cout << found->name; // Direct access!
}
```

#### File Format (Strict Layout)
Wait overhead is minimized as parsing is offset-based.
```
Type\0...,id:"1001\0..."{name:"Alice\0...",age:00030}
```
*No spaces, fixed byte offsets.*

### 2. Using Variable-Length Records

Flexible but slower (O(N) search). Suitable for config files or small datasets. Uses Virtual Function Polymorphism.

```cpp
class Config : public FdFile::VariableRecordBase {
    // Implement toKv() and fromKv() manually...
};

// Requires prototype instances for deserialization
std::vector<std::unique_ptr<VariableRecordBase>> prototypes;
prototypes.push_back(std::make_unique<Config>());

FdFile::VariableFileRepositoryImpl repo("config.txt", std::move(prototypes), ec);
```

---

## [Korean] 사용 가이드

### 1. 고정 길이 레코드 사용 (권장)

고정 길이 레코드는 **O(1) 읽기/쓰기 성능**, **데이터 무결성 보장**, 그리고 **Zero Virtual Function Overhead**를 제공합니다.

#### 단계 1: 레코드 클래스 정의
`FdFile::FixedRecordBase<T>`를 상속받고 (CRTP 패턴), `FD_FIXED_DEFS` 매크로를 사용합니다.

```cpp
#include "fdFileLib/record/FixedRecordBase.hpp"
#include "fdFileLib/record/Macros.hpp"

// CRTP 상속: 본인 타입(User)을 템플릿 인자로 전달
class User : public FdFile::FixedRecordBase<User> {
public:
    char name[20];
    long age;

    // 레이아웃 정의 및 메서드 자동 생성
    // FD_FIXED_DEFS(클래스명, 타입명, 타입길이, ID길이, 필드목록...)
    FD_FIXED_DEFS(User, "User", 10, 10,
        FD_FIELD(name, name, 20, true), // true = 문자열
        FD_FIELD(age, age, 5, false)    // false = 숫자
    )

    // 매크로가 기본 생성자를 자동으로 생성합니다!
    // User() { defineLayout(); }

    // 커스텀 생성자 (선택 사항)
    User(const char* n, long a, long idVal) {
        std::memset(name, 0, sizeof(name));
        if (n) std::strncpy(name, n, sizeof(name));
        age = a;
        setRecordId(std::to_string(idVal));
        defineLayout(); // 커스텀 생성자에서는 반드시 defineLayout() 호출
    }
};
```

#### 단계 2: 리포지토리 사용
`UniformFixedRepositoryImpl<T>` (템플릿)을 사용합니다. `dynamic_cast` 캐스팅이 필요 없습니다.

```cpp
#include "fdFileLib/repository/UniformFixedRepositoryImpl.hpp"

// 'User' 타입을 위한 리포지토리 생성
std::error_code ec;
// 템플릿 인자로 User 타입을 명시. 프로토타입 객체 전달 불필요.
FdFile::UniformFixedRepositoryImpl<User> repo("data.db", ec);

// 저장
User user("Alice", 30, 1001);
repo.save(user, ec);

// 조회 (현재는 O(N) 순차 탐색)
auto found = repo.findById("1001", ec);
if (found) {
    // found는 std::unique_ptr<User> 타입입니다.
    std::cout << found->name; // 바로 접근 가능!
}
```

### 2. 가변 길이 레코드 사용

유연하지만 속도가 느립니다 (O(N) 탐색). 설정 파일이나 작은 데이터셋에 적합합니다. 가상 함수 다형성을 사용합니다.

```cpp
class Config : public FdFile::VariableRecordBase {
    // toKv() 와 fromKv() 수동 구현...
};

FdFile::VariableFileRepositoryImpl repo("config.txt", prototypes, ec);
```
